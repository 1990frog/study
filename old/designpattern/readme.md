# Mybatis至少遇到了以下的设计模式的使用：

+ Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；
+ 工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；
+ 单例模式，例如ErrorContext和LogFactory；
+ 代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；
+ 组合模式，例如SqlNode和各个子类ChooseSqlNode等；
+ 模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；
+ 适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；
+ 装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；
+ 迭代器模式，例如迭代器模式PropertyTokenizer；

# 设计模式一般分为三类：创建型模式、结构型模式、行为型模式。

## 创建型模式

创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。

+ 单例模式：确保某一个类只有一个实例，并且提供一个全局访问点。
+ 建造者模式： 用来创建复杂的复合对象。
+ 工厂方法模式 ：让子类来决定要创建哪个对象。
+ 抽象工厂模式：创建多个产品族中的产品对象。
+ 原型模式：通过复制原型来创建新对象。

## 行为型模式

行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：
策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

+ 策略模式：封装不同的算法，算法之间能互相替换。
+ 状态模式：根据不同的状态做出不同的行为。
+ 责任连模式：将事件沿着链去处理。
+ 观察者模式：状态发生改变时通知观察者，一对多的关系。
+ 模板方法模式：定义一套流程模板，根据需要实现模板中的操作。
+ 迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素。
+ 备忘录模式：保存对象的状态，在需要时进行恢复。
+ 访问者模式：稳定数据结构中，定义新的操作行为。
+ 中介者模式：将网状结构转变为星型结构，所有行为都通过中介。
+ 解释器模式：定义语法，并对其进行解释。
+ 命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。

## 结构型模式

结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

+ 代理模式 ：控制客户端对对象的访问。
+ 组合模式：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。
+ 适配器模式：将原来不兼容的两个类融合在一起。
+ 装饰者模式 ：为对象添加新功能。
+ 享元模式：使用对象池来减少重复对象的创建。
+ 外观模式 ：对外提供一个统一的接口用来访问子系统。
+ 桥接模式：将两个能够独立变化的部分分离开来。

其他设计模式
另外，除了这23种经典的设计模式，还涌现出其他的一些新的设计模式，比如：规格模式、对象池模式、雇工模式、黑板模式和空对象模式等等。后面有时间的话也会对这些模式进行分析。

最后
虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。
但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。
另外，设计模式的各种角色也不是固定不变的，根据实际需要，我们可以适当的进行改动。Android的源码在这方面的改动就比较多。

由于上面那23种经典的设计模式提出来的时间也比较久了，一些设计模式，比如解释器模式，在我们的实际开发中基本上用不到，了解一下就可以了。同时，随着语言和技术的发展，有些模式可能已经过时。所以，我们要紧跟时代的发展。

