[TOC]

# 二叉树
将数据使用树结构存储后，出奇的高效
+ 二分搜索树（Binary Search Tree）
+ 平衡二叉树：AVL，红黑树
+ 堆，并查集
+ 线段树，Trie（字典树，前缀树）

二叉树具有唯一根节点
二叉树每个节点最多右两个孩子（每一棵二叉树，每个节点的子树也是二叉树）
二叉树每个节点最多有一个父亲
二叉树具有天然的递归结构（链表也右，但由于其是线性的，使用循环也能解决问题）
```java
class Node {
    E e;
    /*左孩子*/
    Node left;
    /*右孩子*/
    Node right;
}
```
# 二分搜索树
二分搜索树是二叉树，其每个节点的值，大于其左子树的所有节点的值，小于其右子树的说有节点的值。

# 树的遍历（搜索）
遍历二叉树
+ L遍历左子树
+ D访问根结点
+ R遍历右子树

先(根)序遍历二叉树的顺序是DLR
中(根)序遍历二叉树的顺序是LDR
后(根)序遍历二叉树的顺序是LRD

还有按层遍历二叉树。这些方法的时间复杂度都是O(n)，n为结点个数
## 深度优先遍历
### 前序遍历(Pre-Order Traversal)
指先访问根，然后访问子树的遍历方式
![](https://gitee.com/caijingquan/imagebed/raw/master/https://gitee.com/caijingquan/imagebed/20220504160439.svg)
### 中序遍历(In-Order Traversal)
指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式
### 后序遍历(Post-Order Traversal)
指先访问子树，然后访问根的遍历方式
## 广度优先遍历
和深度优先遍历不同，广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。

# 后继
被删除节点右子树中最小的节点 successor
被删除节点左子树的最大值 前驱

# todo
数组存储二叉树

---

递归
重复利用函数本身能实现的功能，按照顺序进行不断地自调用

函数主要包含：
1.尽头判断
2.实现需要完成的功能
3.对下一跳/项进行函数自身的调用


归纳（Induction）强调从 base case 开始通过不断的 induction step 来「演绎」或者说递推出一个可以推广到所有情况的性质，或者「构造」出一个对象。
递归（recursion）强调的则是 self-referential（自指），比如 recursive definition 是依赖自己指向自己来完成的「递归定义」。
几个区分点：「归纳定义」通常是自指的，所以「归纳定义」常常也是「递归定义」，这就导致最后大家常常就 interchangbly 得用了……但其实一个没有「自指」的枚举类型同样是归纳的「递归」函数常常是需要 base case 得，但是注意「递归」函数完全可以是「发散」（类似无限循环）的。


