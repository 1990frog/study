建造者模式（Builder pattern）

# 概览
创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。
## 用途
使用Builder大概有两个用途
+ 解决具有大量参数的构造函数不好用的问题（简化复杂对象的创建）
+ 解决让Object始终保持valid状态的问题
## UML类图 & 组成
![][../../resources/builder_01.png]
## 角色
+ 建造者（Builder）：对复杂对象的创建过程加以抽象，给出一个抽象接口，以规范产品对象的各个组成部分的建造。
+ 具体创建者（ConcreateBuilder）：实现Builder接口，针对不同的业务逻辑，具体化复杂对象的各个部分的创建。在建造过程完成后，提供产品的实例
+ 指导者（Dierctor）：调用具体建造者来创建复杂对象的各个部分，在指导者中不设计具体产品的信息，只负责保证对象各部分完整创建或者按某种顺序创建。
+ 产品（Product）：要创建的复杂对象，一般来说包含多个部分。
## 优点
+ 建造模式的使用使得产品的内部表象可以独立地变化。使用建造模式可以使客户端不必知道产品内部组成的细节。
+ 每一个Builder都相对独立，而与其他的Builder无关。
+ 模式所建造的最终产品更易于控制。
## 缺点
+ 建造者模式的"加工工艺"是暴露的，这样使得建造者模式更加灵活，也使得工艺变得对客户不透明。
## 背景
Java支持使用constructor初始化一个object，但是如果object的成员非常多，constructor就不好用了。巨长的参数列表很难分清楚哪个是哪个。这时最好用某种方式让哪个字段是哪个更加清晰一点。Builder模式算是可以解决这个问题。此外题主在题目中那种让setter返回this的形式也可以解决。并且，能用"."连接下来配合IDE的自动提示还能够提高编码速度，这算是一个额外的便利。
当一个类的内部数据过于复杂的时候（通常是负责持有数据的类，比如Config、VO、PO、Entity...），要创建的话可能就需要了解这个类的内部结构，还有这些东西是怎么组织装配等一大坨乱七八糟的东西，这个时候就会增加学习成本而且会很混乱，这个时候就想啊想一种什么法子来管理一下这个类中的数据呢，怎么在创建的时候让它按部就班的来，并且代码可读性很好别让我看花了眼啊，我要的东西也能都很好设置进来，这就是Builder模式的应用场景，Builder模式可以将一个类的构建和表示进行分离。
## 适用场景
+ 隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果
+ 多个部件都可以装配到一个对象中，但产生的运行结果不相同
+ 产品类非常复杂或者产品类因为调用顺序不同而产生不同作用
+ 初始化一个对象时，参数过多，或者很多参数具有默认值
+ Builder模式不适合创建差异性很大的产品类
+ 产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本
+ 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
## 模式讲解
+ 指挥者（Director）直接和客户（Client）进行需求沟通
+ 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）
+ 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）
+ 各个具体建造者负责进行产品部件的构建
+ 最终构建成具体产品（Product）
## 例子
```text
造汽车 & 买汽车。
工厂（建造者模式）：负责制造汽车（组装过>程和细节在工厂内）
汽车购买者（用户）：你只需要说出你需要的>型号（对象的类型和内容），然后直接购买就可>>以使用了
（不需要知道汽车是怎么组装的（车轮、车门、>发动机、方向盘等等））
```
## 5.建造者模式与抽象工厂模式的比较:
+ 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。
+ 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。
+ 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车
